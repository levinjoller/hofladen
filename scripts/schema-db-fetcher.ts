// Generated by Google Gemini
import { Client } from "pg";
import { ColumnMeta } from "./schema-generator-utils";

type ParamMeta = {
  param_name: string;
  data_type: string;
  udt_name: string;
  enum_values: string[] | null;
};

type DbSchemas = {
  tables: Map<string, ColumnMeta[]>;
  views: Map<string, ColumnMeta[]>;
  functions: Map<string, ParamMeta[]>;
  enumValues: Map<string, string[]>;
};

export async function fetchDbSchemas(
  client: Client,
  schema: string
): Promise<DbSchemas> {
  const enumValues = await fetchEnums(client, schema);
  const { tables, views } = await fetchTableAndViewColumns(
    client,
    schema,
    enumValues
  );
  const functions = await fetchFunctionParams(client, schema, enumValues);

  for (const columns of views.values()) {
    for (const column of columns) {
      column.is_nullable = "NO";
    }
  }

  return {
    tables,
    views,
    functions,
    enumValues,
  };
}

async function fetchEnums(
  client: Client,
  schema: string
): Promise<Map<string, string[]>> {
  const res = await client.query(
    `SELECT t.typname AS enum_name, e.enumlabel AS enum_value
     FROM pg_type t
     JOIN pg_enum e ON e.enumtypid = t.oid
     JOIN pg_namespace n ON n.oid = t.typnamespace
     WHERE n.nspname = $1
     ORDER BY t.typname, e.enumsortorder;`,
    [schema]
  );

  const enumValues = new Map<string, string[]>();
  for (const row of res.rows) {
    if (!enumValues.has(row.enum_name)) enumValues.set(row.enum_name, []);
    enumValues.get(row.enum_name)!.push(row.enum_value);
  }
  return enumValues;
}

async function fetchTableAndViewColumns(
  client: Client,
  schema: string,
  enumValues: Map<string, string[]>
): Promise<{
  tables: Map<string, ColumnMeta[]>;
  views: Map<string, ColumnMeta[]>;
}> {
  const tableRes = await client.query(
    `SELECT table_name FROM information_schema.tables WHERE table_schema = $1 AND table_type = 'BASE TABLE';`,
    [schema]
  );
  const tableNames = new Set(tableRes.rows.map((r) => r.table_name));

  const viewRes = await client.query(
    `SELECT table_name FROM information_schema.views WHERE table_schema = $1;`,
    [schema]
  );
  const viewNames = new Set(viewRes.rows.map((r) => r.table_name));

  const columnRes = await client.query(
    `SELECT 
        c.table_name, 
        c.column_name, 
        c.data_type, 
        c.udt_name, 
        c.character_maximum_length,
        c.is_nullable
      FROM 
        information_schema.columns c
      WHERE 
        c.table_schema = $1 
      ORDER BY 
        c.table_name, c.ordinal_position;`,
    [schema]
  );

  const tablesMap = new Map<string, ColumnMeta[]>();
  const viewsMap = new Map<string, ColumnMeta[]>();

  for (const row of columnRes.rows) {
    const columnMeta: ColumnMeta = {
      table_name: row.table_name,
      column_name: row.column_name,
      data_type: row.data_type,
      is_nullable: row.is_nullable,
      character_maximum_length: row.character_maximum_length,
      is_primary_key: false,
      check_constraint: null,
      enum_values: enumValues.get(row.udt_name) || null,
    };

    if (tableNames.has(row.table_name)) {
      tablesMap.set(
        row.table_name,
        (tablesMap.get(row.table_name) || []).concat(columnMeta)
      );
    } else if (viewNames.has(row.table_name)) {
      viewsMap.set(
        row.table_name,
        (viewsMap.get(row.table_name) || []).concat(columnMeta)
      );
    }
  }
  return { tables: tablesMap, views: viewsMap };
}

async function fetchFunctionParams(
  client: Client,
  schema: string,
  enumValues: Map<string, string[]>
): Promise<Map<string, ParamMeta[]>> {
  const res = await client.query(
    `SELECT p.proname AS function_name, p.proargnames, p.proargtypes
     FROM pg_proc p
     JOIN pg_namespace n ON p.pronamespace = n.oid
     WHERE n.nspname = $1 AND p.prokind = 'f'`,
    [schema]
  );

  const funcMap = new Map<string, ParamMeta[]>();

  for (const row of res.rows) {
    const paramNames: (string | null)[] = row.proargnames || [];
    const typeOids: number[] = row.proargtypes.trim().split(" ").map(Number);
    const typRes = await client.query(
      `SELECT oid, typname FROM pg_type WHERE oid = ANY($1)`,
      [typeOids]
    );

    const oidToType = new Map<number, string>();
    for (const trow of typRes.rows) {
      oidToType.set(trow.oid, trow.typname);
    }

    const params = typeOids.map((oid, i) => {
      const typname = oidToType.get(oid) || "unknown";
      return {
        param_name: paramNames[i] ?? `param${i + 1}`,
        data_type: typname,
        udt_name: typname,
        enum_values: enumValues.get(typname) || null,
      };
    });
    funcMap.set(row.function_name, params);
  }
  return funcMap;
}
