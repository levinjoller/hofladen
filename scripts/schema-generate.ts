// Generated through Google Gemini
import { Client } from "pg";
import { writeFileSync, mkdirSync, existsSync, rmSync } from "fs";
import path from "path";
import { fileURLToPath } from "url";
import {
  getZodType,
  toPascalCase,
  toKebabCase,
  ColumnMeta,
} from "./schema-utils";
import { config } from "./schema-config";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function fetchViewsColumns(
  client: Client,
  schema: string
): Promise<Map<string, ColumnMeta[]>> {
  const enumQuery = `
    SELECT
      t.typname AS enum_name,
      e.enumlabel AS enum_value
    FROM pg_type AS t
    JOIN pg_enum AS e ON e.enumtypid = t.oid
    JOIN pg_namespace AS n ON n.oid = t.typnamespace
    WHERE n.nspname = $1
    ORDER BY t.typname, e.enumsortorder;
  `;
  const enumRes = await client.query(enumQuery, [schema]);

  const enumValues = new Map<string, string[]>();
  for (const row of enumRes.rows) {
    if (!enumValues.has(row.enum_name)) {
      enumValues.set(row.enum_name, []);
    }
    enumValues.get(row.enum_name)!.push(row.enum_value);
  }

  const viewsQuery = `
    SELECT table_name
    FROM information_schema.views
    WHERE table_schema = $1;
  `;
  const viewsRes = await client.query(viewsQuery, [schema]);
  const viewNames = new Set(viewsRes.rows.map((row) => row.table_name));

  const columnQuery = `
    SELECT
      c.table_name,
      c.column_name,
      c.data_type,
      c.udt_name,
      c.is_nullable,
      c.character_maximum_length
    FROM information_schema.columns AS c
    WHERE c.table_schema = $1
    ORDER BY c.table_name, c.ordinal_position;
  `;
  const columnRes = await client.query(columnQuery, [schema]);

  const viewsMap = new Map<string, ColumnMeta[]>();
  for (const row of columnRes.rows) {
    if (!viewNames.has(row.table_name)) continue;

    const col: ColumnMeta = {
      table_name: row.table_name,
      column_name: row.column_name,
      data_type: row.data_type,
      is_nullable: "NO", // View-Spalten sollen immer required sein
      character_maximum_length: row.character_maximum_length,
      is_primary_key: false,
      check_constraint: null,
      enum_values: enumValues.get(row.udt_name) || null,
    };

    if (!viewsMap.has(row.table_name)) viewsMap.set(row.table_name, []);
    viewsMap.get(row.table_name)!.push(col);
  }

  return viewsMap;
}

async function generateViewSchemas() {
  const client = new Client(config.db);
  try {
    await client.connect();
    console.log("‚úÖ Verbunden mit der Datenbank. Lese Views...");

    const viewsMap = await fetchViewsColumns(client, config.schema);

    const outputDir = path.resolve(__dirname, config.outputDir);
    if (existsSync(outputDir)) {
      console.log(`üßπ L√∂sche alten Ordner: ${outputDir}`);
      rmSync(outputDir, { recursive: true, force: true });
    }
    console.log(`üìÅ Erstelle Ordner: ${outputDir}`);
    mkdirSync(outputDir, { recursive: true });

    for (const [viewName, columns] of viewsMap.entries()) {
      const pascalCaseName = toPascalCase(viewName);
      const kebabName = toKebabCase(viewName);
      const SchemaName = `${pascalCaseName}Schema`;
      const TypeName = pascalCaseName;
      const ArraySchemaName = `${pascalCaseName}ArraySchema`;

      const lines = [
        `/**`,
        ` * NOTE: This file is auto-generated by the schema generator.`,
        ` * DO NOT EDIT MANUALLY.`,
        ` */`,
        ``,
        `import { z } from "zod";`,
        ``,
        `export const ${SchemaName} = z.object({`,
        ...columns.map((col) => `  ${col.column_name}: ${getZodType(col)},`),
        `});`,
        ``,
        `export type ${TypeName} = z.infer<typeof ${SchemaName}>;`,
        ``,
        `export const ${ArraySchemaName} = z.array(${SchemaName});`,
        ``,
      ];

      const filePath = path.join(outputDir, `${kebabName}.ts`);
      writeFileSync(filePath, lines.join("\n"));
      console.log(`‚úÖ Schema f√ºr View "${viewName}" generiert.`);
    }

    console.log("üèÅ Alle View-Schemas erfolgreich erstellt.");
  } catch (err) {
    console.error("‚ùå Fehler beim Generieren:", err);
  } finally {
    await client.end();
  }
}

generateViewSchemas();
