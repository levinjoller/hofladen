// Generated by Google Gemini
import { Client } from "pg";
import { writeFileSync, mkdirSync, existsSync, rmSync } from "fs";
import path from "path";
import { fileURLToPath } from "url";
import {
  getZodType,
  toPascalCase,
  toKebabCase,
  ColumnMeta,
} from "./schema-utils";
import { config } from "./schema-config";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function fetchViewsColumns(
  client: Client,
  schema: string,
  enumValues: Map<string, string[]>
): Promise<Map<string, ColumnMeta[]>> {
  const viewsRes = await client.query(
    `SELECT table_name FROM information_schema.views WHERE table_schema = $1;`,
    [schema]
  );
  const viewNames = new Set(viewsRes.rows.map((r) => r.table_name));

  const columnRes = await client.query(
    `SELECT table_name, column_name, data_type, udt_name, character_maximum_length
     FROM information_schema.columns WHERE table_schema = $1 ORDER BY table_name, ordinal_position;`,
    [schema]
  );

  const viewsMap = new Map<string, ColumnMeta[]>();
  for (const row of columnRes.rows) {
    if (!viewNames.has(row.table_name)) continue;

    viewsMap.set(
      row.table_name,
      (viewsMap.get(row.table_name) || []).concat({
        table_name: row.table_name,
        column_name: row.column_name,
        data_type: row.data_type,
        is_nullable: "NO", // Corrected by post-schema-generate.ts
        character_maximum_length: row.character_maximum_length,
        is_primary_key: false,
        check_constraint: null,
        enum_values: enumValues.get(row.udt_name) || null,
      })
    );
  }
  return viewsMap;
}

async function fetchFunctionsWithEnums(
  client: Client,
  schema: string,
  enumValues: Map<string, string[]>
) {
  const res = await client.query(
    `SELECT p.proname AS function_name, p.proargnames, p.proargtypes
     FROM pg_proc p
     JOIN pg_namespace n ON p.pronamespace = n.oid
     WHERE n.nspname = $1 AND p.prokind = 'f'`,
    [schema]
  );

  const funcMap = new Map<
    string,
    {
      param_name: string;
      data_type: string;
      udt_name: string;
      enum_values: string[] | null;
    }[]
  >();

  for (const row of res.rows) {
    const paramNames: (string | null)[] = row.proargnames || [];
    const typeOids: number[] = row.proargtypes.trim().split(" ").map(Number);

    const typRes = await client.query(
      `SELECT oid, typname FROM pg_type WHERE oid = ANY($1)`,
      [typeOids]
    );

    const oidToType = new Map<number, string>();
    for (const trow of typRes.rows) {
      oidToType.set(trow.oid, trow.typname);
    }

    const params = typeOids.map((oid, i) => {
      const typname = oidToType.get(oid) || "unknown";
      return {
        param_name: paramNames[i] ?? `param${i + 1}`,
        data_type: typname,
        udt_name: typname,
        enum_values: enumValues.get(typname) || null,
      };
    });

    funcMap.set(row.function_name, params);
  }
  return funcMap;
}

async function generateViewSchemas() {
  const client = new Client(config.db);
  try {
    await client.connect();

    const enumRes = await client.query(
      `SELECT t.typname AS enum_name, e.enumlabel AS enum_value
       FROM pg_type t
       JOIN pg_enum e ON e.enumtypid = t.oid
       JOIN pg_namespace n ON n.oid = t.typnamespace
       WHERE n.nspname = $1
       ORDER BY t.typname, e.enumsortorder;`,
      [config.schema]
    );

    const enumValues = new Map<string, string[]>();
    for (const row of enumRes.rows) {
      if (!enumValues.has(row.enum_name)) enumValues.set(row.enum_name, []);
      enumValues.get(row.enum_name)!.push(row.enum_value);
    }

    const viewsMap = await fetchViewsColumns(client, config.schema, enumValues);
    const functionsMap = await fetchFunctionsWithEnums(
      client,
      config.schema,
      enumValues
    );

    const outputDir = path.resolve(__dirname, config.outputDir);
    if (existsSync(outputDir)) {
      console.log(`üßπ L√∂sche alten Ordner: ${outputDir}`);
      rmSync(outputDir, { recursive: true, force: true });
    }
    console.log(`üìÅ Erstelle Ordner: ${outputDir}`);
    mkdirSync(outputDir, { recursive: true });
    console.log("‚úÖ Generiere Zod-Schemas f√ºr Views...");
    for (const [viewName, columns] of viewsMap.entries()) {
      const PascalName = toPascalCase(viewName);
      const kebabName = toKebabCase(viewName);
      const SchemaName = `${PascalName}Schema`;
      const ArraySchemaName = `${PascalName}ArraySchema`;

      const lines = [
        `/**`,
        ` * NOTE: Auto-generated - DO NOT EDIT`,
        ` */`,
        `import { z } from "zod";`,
        ``,
        `export const ${SchemaName} = z.object({`,
        ...columns.map((col) => `  ${col.column_name}: ${getZodType(col)},`),
        `});`,
        ``,
        `export type ${PascalName} = z.infer<typeof ${SchemaName}>;`,
        ``,
        `export const ${ArraySchemaName} = z.array(${SchemaName});`,
        ``,
      ];

      writeFileSync(path.join(outputDir, `${kebabName}.ts`), lines.join("\n"));
      console.log(`‚úÖ Schema f√ºr View "${viewName}" generiert.`);
    }
    console.log("\n‚úÖ Generiere Zod-Schemas f√ºr Funktions-Parameter...");
    for (const [functionName, params] of functionsMap.entries()) {
      const PascalName = toPascalCase(functionName);
      const kebabName = toKebabCase(functionName);
      const SchemaName = `${PascalName}ParamsSchema`;

      const lines = [
        `/**`,
        ` * NOTE: Auto-generated - DO NOT EDIT`,
        ` */`,
        ``,
        `import { z } from "zod";`,
        ``,
        `export const ${SchemaName} = z.object({`,
        ...params.map(
          (p) =>
            `  ${p.param_name}: ${
              p.enum_values
                ? `z.enum(${JSON.stringify(p.enum_values)})`
                : getZodType(p)
            },`
        ),
        `});`,
        ``,
        `export type ${PascalName}Params = z.infer<typeof ${SchemaName}>;`,
        ``,
      ];

      writeFileSync(
        path.join(outputDir, `${kebabName}-params.ts`),
        lines.join("\n")
      );
      console.log(`‚úÖ Schema f√ºr Funktion "${functionName}" generiert.`);
    }
    console.log("\nüèÅ Alle Schemas erfolgreich erstellt.");
  } catch (err) {
    console.error("‚ùå Fehler beim Generieren:", err);
  } finally {
    await client.end();
  }
}

generateViewSchemas();
